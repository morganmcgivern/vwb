(defun singleton-p (l)
  (= (length l) 1)
)
(defun rac (l)
  (cond
    ((null l) (cdr l))
    ((singleton-p l) (car l))
    (T (rac (cdr l)))
  )
)

(defun rdc (l)
  (cond
    ((null l) '())
    ((singleton-p l) '())
    (T (cons (car l) (rdc (cdr l))))
    )
)
(defun snoc (a b)
  (if (null b) (list a)
  (cons (car b) (snoc a (cdr b)))
  )
 )

(defun palindrome-p (l)
  (cond
    ((null l) T)
    ((singleton-p l) T)
    ((equal (car l) (rac l)) (palindrome-p (cdr (rdc l))))
    (T nil)
  )
)

(defun select (l index)
  (if (= index 0)
    (car l)
  (select (cdr l) (- index 1)))
)
(defun pick (l)
  (select l (random (length l)))
  )

(defun sum (l)
  (cond
    ((null l) '0)
    ((singleton-p l) (car l))
    (T (+ (car l) (sum (cdr l))))
  )
)
(defun product (l)
  (if (singleton-p l) (car l)
    (* (car l) (product (cdr l)))
  )
)
(defun iota (l)
  (if (= l 0) '()
    (snoc l (iota (- l 1)))
  )
)

(defun factorial (x)
  (product (iota x)))
(defun duplicate (n l)
  (if (= n 0) ()
    (snoc l (duplicate (- n 1) l)))
)

(defun power (x y)
  (product (duplicate y x)))

(defun filter-in (p l)
  (if (null l) '()
    (let*
      ((element (car l))
       (remainder (remove element l :count 1))
       )
      (if (not (funcall p element))
        (append (list element) (filter-in p remainder))
        (filter-in p remainder))
      )
    )
)

(defun filter-out (p l)
  (if (null l) '()
    (let*
      ((element (car l))
       (remainder (remove element l :count 1))
       )
      (if (funcall p element)
        (append (list element) (filter-out p remainder))
        (filter-out p remainder))
      )
    )
)

(defun take-from (elem l)
  (remove elem l)
)

(defun random-permutation (l)
  (if (null l) '()
    (let*
      ((element (pick l))
       (remainder (remove element l :count 1))
       )
      (append (list element) (random-permutation remainder))
    )
    ))
